=head1 NAME
X<operator, secret>

perlsecret - Perl secret operators and constants

=head1 SYNOPSIS

Perl secret operators:

    Operator     Nickname                Function
    ================================================
    0+           Venus                   numification
    @{[ ]}       Babycart                list interpolation
    !!           Bang bang               boolean conversion
    }{           Eskimo greeting         END block for one-liners
    ~~           Inchworm                scalar
    ~-           Inchworm on a stick     high-precedence decrement
    -~           Inchworm on a stick     high-precedence increment
    -+-          Space station           high-precedence numification
    =( )=        Goatse                  scalar / list context
    =< >=~       Flaming X-Wing          match input and assign captures
    ~~<>         Sperm
    <<m=~>> m ;  Ornate double-bladed sword
    -=!   -=!!   Flathead
    +=!   +=!!   Phillips
    x=!   x=!!   Pozidriv
    *=!   *=!!   Torx

Perl secret constants:

    Constant     Nickname                Value
    =================================================
    <=><=><=>    Space fleet             0
    <~>          Amphisbaena             $ENV{HOME}

=head1 DESCRIPTION

Perl has a long tradition of giving nicknames to some of its operators
(a form of Huffmanisation?). These nicknames are based on the appearance
of the operator, rather than its function. The well-known examples
are the I<diamond operator> (C<< <> >>) and the I<spaceship operator>
(C<< <=> >>). Some lesser known Perl operators with a nickname are
the I<fat comma> (C<< => >>) and I<yada yada> (C<< ... >>).

The Perl "I<secret operators>" have been discovered (or created) by
Perl obfuscators and golfers, usually when looking for a shorter way to
perform a given operation.
These secret "operators" are not operators in the sense that the Perl
parser recognize them, but in the sense that these Perl programmers
have seen them often enough to recognize them and eventually add them
to their toolbox.
These "secret" operators are not secret in the sense that the Perl
community is trying to hide them from the general public, but in the
sense that they have to be discovered by their future user (or be
transmitted by a fellow programmer), because there are not explicitely
documented.

The secret operators often have nicknames. Actually, they B<have> to
have a nickname, because they usually don't have a real name.
Like the above Perl operators, their name is usually related to their shape.

The term "secret operator" was probably coined by Abigail in a
C<comp.lang.perl.misc> post in January 2003.

=head2 A word of warning

There is a good reason this page is not listed in the main documentation
page: many of those "operators" are not suitable for production use.
The secret operators are used by golfers, obfuscators and people who like
to have fun with their favorite programming language. It also wouldn't
be much of a secret if it was listed in the main manual page. C<;-)>

You're welcome to try these at home, but they might not be safe for work!

=head1 SECRET OPERATORS

The following section presents the Perl secret operators, with
some historical context, an explanation of how they work and
examples of use.

=head2 Venus C< 0+ > or C< +0 >

The I<Venus> operator performs the numification of the value on its
right/left, depending of the version used. (This is accomplished by
using the identity element for the addition).

    print 0+ '23a';                 # 23

    print 0+ '3.00';                # 3

    print 0+ '1.2e3';               # 1200

    print 0+ '42 EUR';              # 42

    print 0+ 'two cents';           # 0

    $ref = [];
    print 0+ $ref, ' ', "$ref";     # 164094424 ARRAY(0x9c7e1d8)

    print 0+ $!, ' ', $!;           # 2 No such file or directory


Note that C<0+> is the method name used for "numeric conversion" by
the C<autoload> module.

=head2 Baby cart C<< @{[ ]} >>

Discovered by Randal L. Schwartz, 1994.
(Alternate nicknames: "shopping-trolley", "pram", "turtle")

The I<baby cart> operator performs list interpolation inside a string.
The list items are separated by the value of C<$">.

    # SQL in a heredoc
    local $" = ',';
    my $sth = $self->execute( << "SQL" );
     SELECT id, name, salary
       FROM employee
      WHERE id IN (@{[ keys %employee ]})
    SQL

    # process args in %arg
    # and spit out the unknown ones
    die "Uuh?: @{[ sort keys %arg ]}\n"

This is a I<container> (or a I<circumfix> operator). The expression
inside the C<[]> is run in list context, stored in an anonymous array,
which is immediately dereferencedi by C<@{}>.

=head2 Bang bang C<!!>

This operator performs boolean conversion, by performing logical negation
twice.

    my $true  = !! 'a string';   # now 1
    my $false = !! undef;        # now ''

=head2 Eskimo greeting C<< }{ >>

Discovered by Abigail, in the late nineties.

The I<eskimo greeting> operator is an C<END> block for one-liners.

The following program counts and prints the number of lines in the input:

    $ perl -lne '}{print$.'

The eskimo greeting abuses the way the B<-p> and B<-n> options generate
Perl code (as shown by using the C<B::Deparse> module):

    $ perl -MO=Deparse -lne '}{print$.'
    -e syntax OK
    BEGIN { $/ = "\n"; $\ = "\n"; }
    LINE: while (defined($_ = <ARGV>)) {
        chomp $_;
    }
    {
        print $.;
    }

=head2 Inchworm C< ~~ >

This operator is basically a shorter C<scalar> (shaves 4 characters!)

    $ perl -lEsay~~localtime
    Tue Mar 13 19:53:25 2012

The inchworm looks very much like the smart-match operator introduced
in Perl 5.10, but since it's actually a sequence of two unary operators,
the Perl parser can't mix it up with the binary smart-match.

Note that Perl's C<~> is operand sensitive; if its operand has a numeric
value (either because it was assigned a number, the result of a numeric
operation, or had been used in numeric context), it is a numeric bitwise
or (implicitly converting to UV, or under the scope of C<use integer>,
IV, first); otherwise it is a string bitwise or.

For most inputs, in either case it can be repeated to reproduce the
original value and acts just like scalar().

Examples of exceptions:

    # floating point
    $x = 1.23;
    print ~~$x;                # 1

    # string used in numeric context
    $x = "1.23";
    print ~~$x if $x != 0;     # 1

    # integer out of range
    use Config '%Config';

    $x = 2**( 8 * $Config{uvsize} );
    print ~~$x;                # UV_MAX

    $x = -1;
    print ~~$x;                # UV_MAX

    $x = 2**( 8 * $Config{uvsize} - 1 );
    {
        use integer;
        print ~~$x;            # IV_MIN
    }

    $x = -2**( 8 * $Config{uvsize} - 1 ) - 1;
    {
        use integer;
        print ~~$x;            # IV_MIN
    }

=head2 Inchworm on a stick C< ~- > and C< -~ >

Discovered by Ton Hospel, 2002.

These two operators perform a high-precedence decrement (C<~->) and
high-precedence increment (C<-~>) on integers (on a complement two
architecture).

In C, Python and Ruby, they work on all integers. Due to how C<~>
is implemented in Perl (see the section on I<inchworm>), this pair of
secret operators is limited by default: C<~-> only decrements integers
greater than 0, and C<-~> only increments integers lesser than 0. To
get the inchworms on a stick to work on all integers, they must be used
under the scope of C<use integer>.

This golfing technique allows to get rid of a pair of parentheses:

    $y = ~-$x * 4;    # identical to $y = ($x-1)*4;


Here's the proof:

    $x - 1 == - ( -$x ) - 1

In complement two architectures, to get the opposite of a number,
all you need to do is flip all bits, and add 1. I.e.,

    -$i == ~$i + 1

Using this to replace C< - ( -$x ) > in the above identity, we get:

    $x - 1 == ( ~-$x + 1 ) - 1

And after eliminating the ones from the equation,

    $x - 1 == ~-$x

QED.

For C<-~>, the proof is similar:

    $x + 1 == - ( -$x ) + 1

    $x + 1 == - ( ~$x + 1 ) + 1

    $x + 1 == -~$x - 1 + 1

    $x + 1 == -~$x


In both versions, the high precedence comes from the fact that C<~>
and unary C<-> both have higher precedence than all other arithmetic
operators (except C<**>).

Mnemonic: the backwards-facing inchworm on a stick (C<~->) decrements,
and the forward-facing inchworm on a stick (C<-~>) increments.


=head2 Space station C< -+- >

Discovered by Alistair McGlinchy, 2005.

This operator performs a high precedence numification.

    print -+- '23a';                # 23

    print -+- '3.00';               # 3

    print -+- '1.2e3';              # 1200

    print -+- '42 EUR';             # 42

    print -+- 'two cents';          # 0

    $ref = [];
    print -+- $ref, ' ', "$ref";    # 151097816 ARRAY(0x90191d8)

    print -+- $!, ' ', $!;          # 2 No such file or directory

At first, this looks exactly like the Venus operator. However, because
the Venus operator uses a binary C<+>, it has a lower precedence than
the multiplicative operators like C<*> or C<x>. On the other hand,
the space station operator is the concatenation of three unary operators,
and therefore has higher precedence.

In the following example, we'll try to print the numification of
the string C<'20GBP'> (i.e. C<'20'> repeated three times).

    # wrong: prints the numification of '20GBP20GBP20GBP'
    print 0+ '20GBP' x 3;            # 20

    # wrong: does the equivalent of ( print '20' ) x 3
    print( 0+ '20GBP' ) x 3;         # 20

    # right: but too lengthy, too lispy
    print( ( 0 + '20GBP' ) x 3 );    # 202020

    # right: uses the space station operator
    print -+- '20GBP' x 3;           # 202020

=head2 Goatse C< =( )= >

If you don't understand the name of this operator, consider yourself lucky.
You are advised B<not> to search the Internet for a visual explanation.

The goatse operator provides a list context to its right side and
returns the number of elements to its left side.

    # count the words in $_
    $n =()= /word1|word2|word3/g;

    # $n = 1
    $n =()= "abababab" =~ /a/;

    # $n = 4
    $n =()= "abababab" =~ /a/g;

The goatse operator is a container (sic), so it can also be used to
assign values from the right-hand side to the variables inside it.

    # $n = 4; $b = 'a'
    $n =($b)= "abababab" =~ /a/g;

    # $n = 4; @c = qw( a a a a )
    $n =(@c)= "abababab" =~ /a/g;


Here's a convoluted example where C<=()=> seems to be the proper
construct to use, but it's actually another secret operator that
really does the trick.

Imagine you want to know in how many elements C<< split() >> would split
a string, but do not care about the elements themselves. Using C<split()>
in scalar context:

    my $count = split /:/, $string;

Gives the correct answer, but also a warning:

    Use of implicit split to @_ is deprecated

Using C<=()=> to force scalar context on the left side (to get the number
of substrings) and list context on the right side (to avoid the deprecated
not-in-list-context construct) seems like the proper solution:

    my $count =()= split /:/, $string;

It does not warn indeed, but always returns C<1> (which is usually wrong).

The reason is that C<split()> never splits in more fields than necessary.
And the compiler interprets storing the results in C<()> as not caring
about the results, so C<split()> will B<not split the string at all>
(and thus return the full string, which gives a list of only one element
in scalar context, hence the C<1>).

In this case, the proper secret operator to use is I<baby cart>:

    my $count = @{[ split /:/, $string ]};

which forces C<split()> to actually do the work, before the anonymous
array is thrown away after being used in scalar context.


=head2 Flaming X-Wing C<< =<>=~ >>

Discovered by Philippe Bruhat, 2007.

This operator applies a regular expression to a single line of input
and assigns the captured values to the expression to its left-hand side.

    # pick named fields from input
    @data{@fields} =<>=~ $regexp;

This operator is also a container. So the X-Wing can have a pilot!

    # use the source, Luke!
    $luke = \*DATA;
    @data{@fields} =<$luke>=~ $regexp;

=head2 Kite C<< ~~<> >>

Discovered by Philippe Bruhat, 2012.
(Alternate nickname: "sperm")

This operator is actually a combination of the inchworm and the diamond
operator. It provides scalar context to the C<readline()> builtin, thus
returning a single line of input.

It's only useful in list context (since C<< <> >> already returns a
single line of input in scalare and void contexts), for example for getting
several lines at once:

    @triplets = ( ~~<>, ~~<>, ~~<> );    # three sperms in a single egg?

Mnemonic: It provides a feature that is tied to one line, a string,
as it were. (tye in L<http://www.perlmonks.org/?node_id=959906>).


=head2 Ornate double-bladed sword C<<< <<m=~m>> m ; >>>

Created by Abigail, 2003, for comp.lang.perl.misc.

This operator provides multiline comments, by clever use
of heredoc syntax and beautiful symmetry.
Quoting C<< <slrnb382jc.tfm.abigail@alexandra.abigail.nl> >>:

    <<m=~m>>
      Use the secret operator on the previous line.
      Put your comments here.
      Lots and lots of comments.
    
      You can even use blank lines.
      Finish with a single
    m
    ;

The "ornament" is the C<m> ribbon with the C<;> throwing blade attached
to it.

=head2 Screwdriver operators

Discovered by Dmitry Karasik, 2007, while looking for !-based operators.

All screwdriver operators are conditional operators. Like screwdrivers,
they come in 4 majors types, with different handle lengths.

=over 4

=item Flathead

This operator provides conditional decrement:

    $x -=!! $y     # $x-- if $y;
    $x -=!  $y     # $x-- unless $y;

=item Phillips

This operator provides conditional increment:

    $x +=!! $y;    # $x++ if $y;
    $x +=!  $y;    # $x++ unless $y;

=item Torx

This operator provides conditional reset to C<0>:

    $x *=!! $y;    # $x = 0 unless $y;
    $x *=!  $y;    # $x = 0 if $y;

=item Pozidriv

This operator provides conditional reset to C<''>:

    $x x=!! $y;    # $x = '' unless $y;
    $x x=!  $y;    # $x = '' if $y;

(This one was discovered by Philippe Bruhat in 2009, while preparing a
talk about the secret operators.)

=back

Mnemonic: the screwdriver's head is the best mnemonic (C<-> and C<+>
for increment and decrement, C<*> for the null number, C<x> for the
null string).


=head2 Winking fat comma C<< ,=> >>

Discovered by Abigail, 2010.
(Alternate nickname: "grappling hook")

Visually looks like a fat comma, but without the left-hand side behaviour.

This operator is used to retain the documenting features of the fat comma,
while disabling the string interpretation of the word to its left.

    use constant APPLE   =>  1;
    use constant CHERRY  =>  2;
    use constant BANANA  =>  3;
    
    %hash = (
      APPLE   ,=>  "green",
      CHERRY  ,=>  "red",
      BANANA  ,=>  "yellow",
    );

is equivalent to:

    %hash = ( 1, "green", 2, "red", 3, "yellow" );

Mnemonic: the comma C<,> is an off-switch for the fat comma's stringification.

=head1 SECRET CONSTANTS

=head2 Space fleet C<< <=><=><=> >>

Discovered by Damian Conway.

Even though it looks like a sequence of three spaceship operators,
only the middle ship is an actual spaceship. The two outer "spaceships"
are actually calls to C<glob("=")>.

This constant has the value C<0>.

=head2 Amphisbaena C<< <~> >>

Discovered by Rafaël Garcia-Suarez, 2009.

Under Unix, will be equal to the real user home directory (by using C<glob>).

=head1 AUTHOR

Philippe Bruhat (BooK)

=head1 COPYRIGHT

Copyright 2010 Philippe Bruhat (BooK).

This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.

=head2 Acknowledgments

The author would like to thank José Castro, Andrew Savige, Dmitry
Karasik, Abigail, Yitzchak Scott-Thoennes, Zefram, tye, Maxim Vuets
and the Fun With Perl mailing list.

=cut

