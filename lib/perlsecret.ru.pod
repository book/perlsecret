=encoding utf8

=head1 НАИМЕНОВАНИЕ

perlsecret - Cекретные операторы и константы Perl

=head1 КРАТКИЙ ОБЗОР

Cекретный операторы Perl:

    Оператор     Кличка                       Функция
    ======================================================
    0+           Венус Venus                   Приведение к цифре
    @{[ ]}       Детскаякаляска Babycart       интерполяция списка
    !!           2 удара Bang bang             логическое преобразование
    }{           Эскимосское приветствие       КОНЕЦ блока для однострочного скрипта
    ~~           Дюймовыйчервь Inchworm        скалярный
    ~-           Дюймовыйчервь на палке        декремент высокого приоритета
    -~           Дюймовыйчервь на палке        декремент высокого приоритета
    -+-          Космическая станция           Приведение к цифре высокого приоритета
    =( )=        Гоатсе                        скалярный / списочный контекст
    =< >=~       Пылающий X-Wing Истребитель   ищем во входных данных и присваиваем захваченное
    ~~<>         Кайт, девочка убийца          Одиночная строка ввода
    <<m=~m>> m ; Богатый двухлезвийный меч     Многострочный комментарий
    -=!   -=!!   Плоская                       условное уменьшение
    +=!   +=!!   Прямоугольная                 условное увеличение
    x=!   x=!!   Крестовая                     условный резет на ''
    *=!   *=!!   Шестилучевая отвертка         условный резет на 0
    ,=>          Подмигивающая жирная запятая  не стрингифицирующая жирная запятая
    ()x!!        Предприятие Enterprise        Сквош логического списка
    0+!!         Ключ к истине                 числовое преобразование логических значений
    ||()         Эбботт и Костелло Камеди дуэт удалить ложный скаляр из списка
    //()         Наклонный Эбботта и Костелло  удалить undef из списка

Perl секретные константы:

    Константы   Кличка (Nickname)           Значение
    ======================================================
    <=><=><=>   Космический флот            0
    <~>         Амфисбена Двойной путь      $ENV{HOME}

=head1 ОПИСАНИЕ

Perl имеет давнюю традицию давать прозвища для некоторых из своих операторов
(возможная форма очеловечивания). Эти прозвища основаны на
скорее на виде операторов, чем на их функциях.
Известные примеры I<бриллиантовый оператор> (C<< <> >>),
по прозвищу Стена Женевы и  I<оператор космического корабля> (C<< <=> >>), 
прозванный Рендаль Шварц.
Вот некоторые менее известные операторы Perl с ником I<толстая запятая>
(C<< => >>) и I<болтовня> (C<< ... >>).

"I<Cекретный операторы>" Perl были обнаружены (или созданы)
Perl обфускаторами и Perl гольфистами, обычно при поиске более короткого пути
выполнения операции.
Секретный операторы не являются на самом деле секретными, и они не являются на самом деле
операторами. Perl анализатор специально не признает их,
и не пытается скрывать их от вас.
Но они, являются операторами в том смысле, Perl программистам достаточно посмотреть
 на их конструкцию, чтобы понять, что они делают, не задумываясь о более мелких элементах
 и в конечном итоге добавляют их в свою коллецию инструментов.
Они являются секретами в том смысле, что они должны обнаружены
их будущем пользоватем (программистом), потому что они
явно не описаны в основной документации Perl.

Так как секретные операторы не являются операторами, они не имеют реальных имен, и
поэтому они нуждаются в прозвища (никнеймах).
Как видно из описания Perl операторов выше их имя обычно связано с их формой.

Термин "секретный оператор", вероятно, был придуман Абигейлом в
 сообщении на C<comp.lang.perl.misc> в январе 2003 года.

=head2 Слово предупреждения

Многие из этих "операторов", не подходят для производственного кода,
потому что они являются неясными для непосвященных, хотя некоторые из них - это просто имена
для общих идиом (словосочетаний, фр. idiome «язык, наречие» происх от др.-греч. ἰδίωμα «особенность, своеобразие).
Реально секретные операторы используются гольфистами,
обфускаторами и людьми, которые любят
 повеселиться с их любимым языком программирования.

Вы можете попробовать их дома, но они могут быть не безопасны для работы!

=head1 СЕКРЕТНЫЕ ОПЕРАТОРЫ

В следующем разделе представлены секретные операторы Perl с
некоторым историческим контекстом, объяснением того, как они работают и
примерами использования.

=head2 Венера(Venus)

    0+
    +0

Оператор I<Венера> - это очень распространенный фразеологизм. Он выполняет
превращение в цифру, нумификацию значения стоящего справа/слева
в зависимости от используемых версий. (Это достигается путем
использование идентификатора добавления I<+>).

    print 0+ '23a';                 # 23

    print 0+ '3.00';                # 3

    print 0+ '1.2e3';               # 1200

    print 0+ '42 EUR';              # 42

    print 0+ 'two cents';           # 0

    $ref = [];
    print 0+ $ref, ' ', "$ref";     # 164094424 ARRAY(0x9c7e1d8)

    print 0+ $!, ' ', $!;           # 2 No such file or directory


Обратите внимание, что C<0+> — это имя метода, для "числового преобразования"
 в модуле C<overload>.

=head2 Детская коляска (Baby cart)

    @{[ ]}

Открыта Лари Воллом, 1994.
(Альтернативные клички:  "шоппинг троллей", "коляска", "черепаха")

Оператор I<Детская коляска> выполняет интерполяцию списка внутри строки.
Элементы списка разделяются значением C<$">.

    # SQL в heredoc (документ-здесь)
    local $" = ',';
    my $sth = $self->execute( << "SQL" );
     SELECT id, name, salary
       FROM employee
      WHERE id IN (@{[ keys %employee ]})
    SQL

    # аргументы находятся в хэше %arg
    # и выводятся неизвестные аргументы
    die "Uuh?: @{[ sort keys %arg ]}\n"

Еще один вариант использования – для взлома алиасов (т.е. создании копии); Например,
чтобы избежать фатальной ошибки при C<попытке модификации значения только для чтения>
при выполнении следующего кода:

    for (qw( 1 2 3 )) {
        $_ = $_ * $_;    # надуманный
        print "площадь: $_\n";
    }

С детской коляской (babycart) изменяемые данные фактически копируются в скаляр.

    for ( @{[ qw( 1 2 3 ) ]} ) {
        $_ = $_ * $_;    # надуманный
        print "площадь: $_\n";
    }

Это I<контейнер>, или I<окаймляющий>  (I<циркумфикс>) operator. Выражение внутри 
C<[]> выполняется в списочном контексте и сохраняется в анонимном массиве,
который сразу разыменовывается  с помощью C<@{}>.

Вы это иногда увидите это в рабочем коде.

=head2 2 удара Bang bang

    !!

Этот оператор был в общем использовании программистами C даже до существования Perl.
Он выполняет логическое преобразование, выполняя логическое отрицание
дважды.

    my $true  = !! 'a string';   # теперь 1
    my $false = !! undef;        # теперь ''

=head2 Приветствие Эскимосов (Eskimo greeting)

    }{

(Альтернативный ник: "бабочка")

Открыт Абигалем в 1997.

Оператор I<приветствие Эскимосов> является блоком C<END> для однострочников.

Следующая программа подсчитывает и выводит число строк во входных данных:

    $ perl -lne '}{print$.'

Приветствие Эскимосов злоупотребляет использование опций B<-p> и B<-n> генерируя
Perl код (показано, используя модуль C<B::Deparse>):

    $ perl -MO=Deparse -lne '}{print$.'
    -e syntax OK
    BEGIN { $/ = "\n"; $\ = "\n"; }
    LINE: while (defined($_ = <ARGV>)) {
        chomp $_;
    }
    {
        print $.;
    }

Открытие было сделано после того, как Perl Journal опубликовал интервью с
Чипом Сальзенбергом(Chip Salzenberg), в котором он объяснил, что хак perl использует для реализации
C<< -p >> и C<< -n >>.

Этнографическое примечание: в современной Западной культуре эскимосский поцелуй - это
, когда люди целуются друг с другом соприкасая носы. Это основывается
на традиционном инуитском приветствии, названном I<куник>, ранние исследователи
Арктики назвали его "эскимосский поцелуй" ("Eskimo kissing"), когда они впервые увидели его.
Сам куник не является поцелелуем, он не эротичен, это просто форма нежного приветствия.

=head2 Дюймовый_червь (Inchworm)

    ~~

Этот оператор в основном короче C<scalar>(убирает целых 4 символа!)
используя ту же идею, как секретный оператор bang bang.

    $ perl -Esay~~localtime
    Tue Mar 13 19:53:25 2012

Дюймочервь выглядит очень похоже на смарт матч оператор, представленный
в Perl 5.10, но так как это на самом деле последовательность двух унарных операторов,
анализатор Perl не сможет смешать его с двоичным смарт матчем.

Обратите внимание, что Perl C<~> является чувствительным операндом: если его операнд имеет числовое
значение (либо потому, что был присвоен номер, в результате числовая
операция, или используется в числовом контексте), это побитовое числовое
отрицание (сначала неявно преобразует целое число без знака (unsigned integer (UV)), или 
за областью  C<use L<integer>>, знаковое целое число, (signed integer (IV))); в противном случае это
строковое поразрядное(побитовое) отрицание.

И это объясняет, как эта операция отличается от C<!!>. Вместо того, чтобы заставить операнд
 быть булевым (логическим), он применяет его или к строке или к цифре(в зависимости от операндов).

Таким образом, для большинства входных данных, Дюймочервь (inchworm) действует так же, как C<scalar()>.

Примеры исключений:

    # с плавающей точкой
    $x = 1.23;
    print ~~$x;                # 1

    # строка используется в числовом контексте
    $x = "1.23";
    print ~~$x if $x != 0;     # 1

    # целое число вне диапазона (out of range)
    use Config '%Config';

    $x = 2**( 8 * $Config{uvsize} );
    print ~~$x;                # UV_MAX

    $x = -1;
    print ~~$x;                # UV_MAX

    $x = 2**( 8 * $Config{uvsize} - 1 );
    {
        use integer;
        print ~~$x;            # IV_MIN
    }

    $x = -2**( 8 * $Config{uvsize} - 1 ) - 1;
    {
        use integer;
        print ~~$x;            # IV_MIN
    }

Но это также удобно, как собирательное для получения строки из объектов,
перегрузите его некоторым полезным образом:

    use DateTime;
    use JSON;
    my $now = DateTime->now;
    print encode_json { time => ~~$now };

=head2 Дюймочервь на палке (Inchworm on a stick)

    ~-
    -~

Открыт Томом Хоспелом, 2002.

Эти два оператора выполняют высокоприоритетный декремент (C<~->) и
 высокоприоритетный инкремент(C<-~>) для целых чисел (на архитектуре
дополнительного кода ( two-complement) 
https://ru.wikipedia.org/wiki/Дополнительный_код_(представление_числа)).
Этот трюк программисты языка ассемблера использую на протяжении десятилетий.

В C, Python и Ruby они работают на всех целых числах. Из-за того, как оператор C<~>
реализован в Perl (мало известный факт, что побитовые
операторы Perl приводят операнд к  беззнаковому целому ( unsigned integers) 
  без C<use L<integer>> и к знаковому целому (signed integers) 
  с C<use integer>), эта пара
секретных операторов ограничивается целыми числами со знаком.
Это на самом деле еще большее ограничение, по умолчанию: C<~-> только уменьшает целые числа
больше 0 и C<-~> только увеличивающем целые числа меньше 0. Для того, чтобы
Дюймочервь на палке (Inchworm on a stick)
 работал на всех целых числах, он должен быть использован
в сфере  C<use integer>, таким образом знаковые целые(signed integers)
 используются повсеместно в битовых операциях.

Этот гольф методика позволяет избавиться от пары скобок:

    $y = ~-$x * 4;    # аналогично $y = ($x-1)*4;

Вот доказательство:

    $x - 1 == - ( -$x ) - 1

В двудополнительной архитектуре, чтобы получить обратное числа,
все, что вам нужно сделать это сделать инверсию (flip) всех битов и добавить 1. То есть,

    -$i == ~$i + 1

Используем это, чтобы заменить C< - ( -$x ) > на показанное выше, мы получаем:

    $x - 1 == ( ~-$x + 1 ) - 1

И после устранения единиц из уравнения,

    $x - 1 == ~-$x

ЧТО И ТРЕБОВАЛОСЬ ДОКАЗАТЬ. (QED - от лат. quod erat demonstrandum)

Для C<-~>, доказательство аналогично:

    $x + 1 == - ( -$x ) + 1

    $x + 1 == - ( ~$x + 1 ) + 1

    $x + 1 == -~$x - 1 + 1

    $x + 1 == -~$x

В обеих версиях высокий приоритет исходит из того, что  C<~>
и унарный C<-> оба имеют более высокий приоритет, чем все другие арифметические
операторы (за исключением C<**>).

Мнемосхема: назад стоящий дюймочервь на палке(C<~->) уменьшает,
а дюймочервь по ходу движения на палке (C<-~>) приращяет.

=head2 Космическая станция (Space station)

    -+-

Открыт Алистером Макглинчи, 2005.

Этот оператор выполняет приведение к цифре с высоким приоритетом.

    print -+- '23a';                # 23

    print -+- '3.00';               # 3

    print -+- '1.2e3';              # 1200

    print -+- '42 EUR';             # 42

    $ref = [];
    print -+- $ref, ' ', "$ref";    # 151097816 ARRAY(0x90191d8)

    print -+- $!, ' ', $!;          # 2 Нет такого файла или каталога

Во-первых это выглядит точно как оператор Венеры. Однако, потому что
оператор Венеры  использует двоичный C<+>, он имеет более низкий приоритет, чем
операторы умножения, такие как как C<*> или C<x>.С другой стороны
оператор космической станции является объединением трех унарных операторов,
и поэтому имеет более высокий приоритет.

В следующем примере мы будем пытаться печатать приведнную к цифре строку
 C<'20GBP'> (т.eе C<'20'>) повторенную 3 раза.

    # неправильно: выведет нумификацию '20GBP20GBP20GBP'
    print 0+ '20GBP' x 3;           # 20

    # неправильно: это эквивалентно ( print '20' ) x 3
    print( 0+ '20GBP' ) x 3;        # 20

    # правильно: но слишком длинно, слишком полисповски
    print( ( 0 + '20GBP' ) x 3 );   # 202020

    # верно: использование оператора космическая станция (space station)
    print -+- '20GBP' x 3;          # 202020

Тем не менее, т.к. унарный минус просто заменяеть начальный C <-> или C <+> строки 
их аналогом, космическая станция B<не> переводит в цифры I<строки, начинающиеся с минуса> 
или I <строки, которые не начинаются с числа>:

    print -+- 'two cents';          # +two cents

    print -+- '-2B' x 5;            # -2B-2B-2B-2B-2B

В примере выше, C<-+- '-2B'> производит строку C<'-2B'>,
в то время как C<0+ '-2B'> дал бы ожидаемое число (C<-2>).

=head2 Гоатсе, Коза (Goatse)

    =( )=

(Еще одно имя: "Сатурн")

Если вы не понимаете имя этого оператора, считайте себя счастливчиком.
Вам рекомендуется B<не> искать его в Интернете для визуального объяснения.

Оператор гоатсе предоставляет списочный контекст его правую сторону и
возвращает количество элементов на ее левой стороне.
Обратите внимание, что левая сторона должна обеспечивать скалярный контекст; очевидно списочный
контекст с левой стороны будут получать пустой список в середине.

Объяснение того, что присвоение списка в скалярном контексте возвращает
количество элементов в правой части назначения, независимо от
как много из этих элементов были на самом деле присваивоены переменным. В этом
случае все элементы справа просто передают пустой список
(и поэтому отбрасываются).

    # считает число слов в $_
    $n =()= /word1|word2|word3/g;

    # $n = 1
    $n =()= "abababab" =~ /a/;

    # $n = 4
    $n =()= "abababab" =~ /a/g;

Оператор гоатсе представляет собой контейнер (sic!), поэтому он также может использоваться для
присвоения значения с правой стороны переменным внутри него.

    # $n = 4; $b = 'a'
    $n =($b)= "abababab" =~ /a/g;

    # $n = 4; @c = qw( a a a a )
    $n =(@c)= "abababab" =~ /a/g;

В некоторых случаях полный гоатсе не нужен, потому что нет необходимости
для хранения значения в переменной. Побочный эффект списочного присвоения в
скалярные контексте может быть получен I<правостороннем гоатсе> (C<()=>)
используемый в скалярных контексте имеет другое значение, чем присвоение
 скаляру.
Например:

    # удаление пустых ссылок на массивы
    @arrays = ( [], [1], [ 1, 2 ], [], [ 5 .. 9 ] );

    # @filled = ( [1], [ 1, 2 ], [ 5 .. 9 ] );
    @filled = grep +()= @$_, @arrays;

(C<+> в строке выше не операция, используется, что сказать C<grep>,
что скобки не включают его аргументы.)

Вот запутанный пример, где C<=()=> , представляется, как соответствующей
конструкцией для использования, но это на самом деле еще один секретный оператор,
в действительности это трюк.

Представьте, что вы хотите знать, на сколько элементов  C<< split() >> разобьет 
строку, но не заботится о самих элементах. Используйте  C<< split() >>
в скалярных контексте:

    my $count = split /:/, $string;

Дает правильный ответ, но и предупреждение:

    Use of implicit split to @_ is deprecated
    Использование неявного сплита для @_ не рекомендуется

Использование C<=()=> для приведения к скалярному контексту на левой стороне (чтобы получить число
подстрок) и списочный контекст на правой стороне (чтобы избежать устаревшую
конструкцию не в списочном контексте) кажется, вот правильное решение:

    my $count =()= split /:/, $string;

Она действительно не предупреждает, но всегда возвращает  C<1>(что вообщето неправильно).

Причина того, что C<split()> никогда не разбивается больше полей, чем необходимо.
И компилятор интерпретирует, сохранение результатов в  C<()> , не заботясь о
о результатах, так C<split()> не будет B<разбивать строку на всё>,
и таким образом вернуть полную строку, которая дает список только одного элемента
в скалярном контексте, следовательно C<1>.

У вас есть два варианта решения этой проблемы. Во-первых можно переопределить C<split()>
оптимизацию, явно задавая его разделить на неограниченное число
полей:

    my $count =()= split /:/, $string, -1;

Или же вы можете победить оптимизации с помощью другого секретного оператора
вместо этого I<детской коляской>:

    my $count = @{[ split /:/, $string ]};

Это понуждает C<split()> обнаружить, что вызывающий объект может хранить любое количество
полей, таким образом он будет на самом деле делать работу до того, как анонимный
массив выбрасывается после использования в скалярном контексте.

=head2 Пылающий X-Wing Истребитель (Flaming X-Wing)

     =<>=~

Открыт Филиппом Брюа, 2007.

Этот оператор применяет регулярное выражение к одной строке ввода
и назначает захваченных значения в выражение на его левой стороне.

    # поймать имена полей из входящего потока (input)
    @data{@fields} =<>=~ $regexp;

Объясняетя вышеназванное выражение: C<=~>  обеспечивает скалярный контекст
 для  левой стороны C<< <> >> таким образом, что ищет во входящей строке.
Если регулярное выражение содержит захваты, имеющие структуру массива
 с левой стороны,  C<=> обеспечивает списочный контекст и
захваченные данные назначаются структуре.

Этот оператор также является контейнером. Поэтому X-Wing может иметь пилота!

    # используй исходный текст, Люк!
    $luke = \*DATA;
    @data{@fields} =<$luke>=~ $regexp;

=head2 Кайт (Kite)

     ~~<>

Открыт Филиппом Бруа, 2012.
(Альтернативное название: "сперматазоид")

Этот оператор на самом деле сочетание Дюймочервя и бриллиантового
оператора. Он обеспечивает скалярный контекст встроенному C<readline()>, таким образом, 
возвращая одну строку ввода.

Это полезно только в списочном контексте (так как C<< <> >> уже возвращает
единую линию ввода в скалярном и пустом контекстах), например, для получения
сразу несколько линий:

    @triplets = ( ~~<>, ~~<>, ~~<> );    # три спермы в одно яйцо?

Как и другие операторы, основанные на скобочных конструкциях , кайт
контейнер и может нести полезную нагрузку (в данном случае, дескриптор файла).

Обратите внимание, что когда дескриптор файла дочитан до конца, оператор кайт будет
возвращать пустую строку вместо C <undef>.

Мнемоника: Он обеспечивает функцию, которая привязана к одной строке, строке,
как она была. (Tye Маккуин в L<http://www.perlmonks.org/?node_id=959906>).

=head2 Богатый двухлезвийный меч (Ornate double-bladed sword)

    <<m=~m>>
    m
    ;

Создан Абигалем, 2003, for comp.lang.perl.misc.

Этот оператор обеспечивает многострочные комментарии, путем разумного использования
heredoc-синтаксиса и красивой симметрии.
Цитата C<< <slrnb382jc.tfm.abigail@alexandra.abigail.nl> >>:

    <<m=~m>>
      Используйте тайный оператор в предыдущей строке.
      Запишите ваши комментарии здесь.
      Много и много комментов.

      Вы даже можете использовать пустые строки.
      Закончим с одной    
    m
    ;

"Орнамент" C<m> ленты с C<;> бросает меч, привязанный к нему.

Обратите внимание, что "комментируемый" текст на самом деле строка в двойных кавычках в
 пустом контексте, что может иметь некоторые побочные эффекты.

=head2 Отверточный оператор (Screwdriver)

Открыт Дмитрием Карасиком, 2007, при поиске операторов, основанных на знаке C<!>.

Все отверточные операторы являются условными операторами. Как отвертки,
они приводятся к 4м основным типам, с различными длинами ручек.

=over 4

=item *

Плоская

    -=!!
    -=!

Этот оператор обеспечивает условное уменьшение:

    $x -=!! $y     # $x-- if $y;
    $x -=!  $y     # $x-- unless $y;

=item *

Прямоугольная

    +=!!
    +=!

Этот оператор обеспечивает условное увеличение:

    $x +=!! $y;    # $x++ if $y;
    $x +=!  $y;    # $x++ unless $y;

=item *

Шестилучевая

    *=!!
    *=!

Этот оператор обеспечивает условный сброс на C<0>:

    $x *=!! $y;    # $x = 0 unless $y;
    $x *=!  $y;    # $x = 0 if $y;

Оператор  шестилучевая отвертка не работает должным образом с отрицательными числами
отличными от  C<-1> на Perl версии ниже или равно, чем 5.13.5.
Он также не удается с  C<-1> на Perl версии ниже или равной 5.7.0.

=item *

Крестовая

    x=!!
    x=!

Этот оператор обеспечивает условный сброс на C<''>:

    $x x=!! $y;    # $x = '' unless $y;
    $x x=!  $y;    # $x = '' if $y;

(Это один был обнаружен Филиппом Брюа в 2009 году, при подготовке
лекции о тайных (секретных) операторах.)

=back

Мнемоника: головка отвертки является лучшим мнемоникой ческие (C<-> and C<+>
для инкремента и декремента, C<*> для несуществующего значения (null), C<x> для пустой строки).

=head2 Подмигивающая жирная запятая (Winking fat comma)

    ,=>

Открыта Абигалем, 2010.
(Альтернативное имя: "крюк" "grappling hook")

Визуально выглядит как жирная запятая, но без левой стороннего поведения.

Этот оператор используется для сохранения документированной особенности жирной запятой,
при отключении строкового толкования слова слева.

    use constant APPLE   =>  1;
    use constant CHERRY  =>  2;
    use constant BANANA  =>  3;

    %hash = (
      APPLE   ,=>  "green",
      CHERRY  ,=>  "red",
      BANANA  ,=>  "yellow",
    );

эквивалентно:

    %hash = ( 1, "green", 2, "red", 3, "yellow" );

Мнемоника: запятая C <,> является выключателем для жирной запятой в ее стрингификации (приведении к строке).

=head2 Предприятие (Enterprise)

    ( )x!!

Обнаружил Аристотель на PerlMonks, 2006.
(Альтернативный ник: «NCC-1701», «улитка» "snail")

Часто необходимо условно включать элементы в список:

    my @shopping_list = ('bread', 'milk');
    push @shopping_list, 'apples'   if $cupboard{apples} < 2;
    push @shopping_list, 'bananas'  if $cupboard{bananas} < 2;
    push @shopping_list, 'cherries' if $cupboard{cherries} < 20;
    push @shopping_list, 'tonic'    if $cupboard{gin};

Предприятия позволяет создавать список и добавлять только элементы,
которые удовлетворяет условию, в одной инструкции:

    my @shopping_list = (
        'bread',
        'milk',
       ('apples'   )x!! ( $cupboard{apples} < 2 ),
       ('bananas'  )x!! ( $cupboard{bananas} < 2 ),
       ('cherries' )x!! ( $cupboard{cherries} < 20 ),
       ('tonic'    )x!! $cupboard{gin},
    );

Этот оператор представляет собой контейнер, а это значит, предприятие может иметь 
большой экипаж. 

Предприятие это просто повторение списочного оператора  C<< ()x >>
затем логическое значение (см L<Bang bang> L<Двойной удар> оператор выше), который будет 
интерпретируется как 1 или 0 в числовом контексте. 
Следует отметить, что выражение слева всегда выполняется, независимо от условия. 

Из-за вопросов приоритета, сложных условиях в конце 
оператора ентерпрайз (предприятия) может потребоваться поставить в скобки.

=head2 Ключ к истине  (Key to the truth)

    0+!!

Обнаружен Тоби Инкстер, 2013.

Этот оператор - комбинация операторов Венеры (Venus), и двойного удара(bang bang).
Он просто превращает логическую ложь числовое значение C<0>.

    my $true  = 0+!! 'a string';    # теперь 1
    my $false = 0+!! undef;         # теперь 0

=head2 Эбботт и Костелло Камеди дуэт

    ||()

Обнаружен Ивом Ортоном.

Этот оператор делает ложное значение исчезающим в списочном контексте.
Он просто заменяет ложный скаляр пустым списком.

    my @shopping_list = (
        'bread',
        'milk',
        $this ||(),
        $that ||(),
        'apples'
    );

Мнемоника: один высокий, (а также "прямой человек") и один жирный,
, как в известном комедийном дуэте.

=head2 Наклонный Эбботта и Костелло

    //()

Предложен Дэмиеном Кроткиным, 2014.

Этот оператор работает точно так же, как L<Эбботт и Костелло> , за исключением
того, что он только делает C<undef>  исчезающим в списочном контексте.

Этот оператор работает только в версиях Perl 5.10 выше.

Мнемоника: в этой версии, "прямой человек" склоняется 
(и, поэтому, реальная ассоциативность "(склюняющийся Эботт) и Костелло" ).

=head1 СЕКРЕТНЫЕ КОНСТАНТЫ

=head2 Космический флот (Space fleet)

    <=><=><=>

Открыт Домианом Конвеем.

Даже несмотря на то, что он выглядит как последовательность из трех космических кораблей,
только средний корабль является фактическим кораблем. Два внешних "корабля"
являются на самом деле вызовом C<glob("=")>.

Эта константа имеет значение C<0>.

=head2 Амфисбена Двойной путь (Amphisbaena)

    <~>
    
Обнаружил Рафаэль Гарсия Суарес, 2009.

Под Unix будет равна в домашнему каталогу пользователя (с помощью C <glob>).
На Win32 он будет расширять  C<$ENV{HOME}>, если он установлен (что является довольно редко)
или возвратит C<'~'>.

=head1 АВТОР

Филипп Брюа (книга) 

=head1 БЛАГОДАРНОСТИ

Автор хотел бы поблагодарить José Castro, Andrew Savige, Dmitry
Karasik, Abigail, Yitzchak Scott-Thoennes, Zefram, Tye McQueen, Maxim
Vuets, Aristotle Pagaltzis, Toby Inkster, Ævar Arnfjörð Bjarmason,
Rafaël Garcia-Suarez, Andreas J. König, Andy Armstrong, Pau Amma,
Keith C. Ivey, Michael R. Wolf, Olivier Mengué, Yves Orton, Damien Krotkine,
Diab Jerius, Ивана Бессарабова 
и ожидает (Fun) в списке рассылки Perl вдохновения, предложений и патчей.


=head1 СПОСОБСТВОВАНИЕ

Если вы знаете другие тайные операторы и константы, пожалуйста, дайте мне знать!

Однако, прежде чем отправить мне ваше последнее творение, следует знать, что, хотя
они устанавливаются не в камне, я считаю следующие критерии до
добавление оператора или константы в этот список:

=over 4

=item *

имеет ли он ник? (обычно такое, которое соответствует его художественной ASCII форме),

=item *

используется ли он на самом деле в дикой природе?

=item *

имеет ли он гольф-специфичный интерес? (т.е. он выполняет некоторые полезные
операция в значительно меньше числе символов, чем "нормального" Perl код?)

=item *

имеет ли он исторический интерес?

=back

=head1 ССЫЛКИ

Как показано ниже, большинство действий секретных операторов происходит
в веселом списке рассылки Perl.

=over 4

=item *

В 1993 году, по словам Рэндала Шварца в его "I<Мои пол-жизни с Perl>" ("I<My half-life with Perl>")
 25 июля 2013 на OSCON был доклад:

I<Дочь Ларри (Женева?) названный E<lt>E<gt> оператор для меня (Я назвал E<lt>=E<gt>)>
I<Larry's daughter (Geneva?) named the E<lt>E<gt> operator for me (I named the E<lt>=E<gt>)>

=item *

Post C<< <1994May1.035104.25990@netlabs.com> >> in C<comp.lang.perl>

Ларри Уолл обнаруживает детскую коляску и описывает ее, как «путь,
интерполирующий результаты функции в строку".

=item *

Сообщение C<< <slrnb382jc.tfm.abigail@alexandra.abigail.nl> >> in C<comp.lang.perl.misc>

Абигейл вводит термин "секретный оператор", чтобы описать C<< <<m=~m>> m ; >>.

=item *

L<http://www.nntp.perl.org/group/perl.fwp/2005/02/msg3691.html>

Оригинальное обсуждение "секретных операторов".
Несколько из подробных объяснений на этой странице пришли из этого обсуждения.

=item *

L<http://www.nntp.perl.org/group/perl.fwp/2005/02/msg3708.html>

Описание оператора космической станции.

=item *

L<http://www.nntp.perl.org/group/perl.fwp/2005/02/msg3712.html>

Филипп Брюа использует слово "Венера"("venus"), чтобы описать  C<0+>.

=item *

L<http://www.nntp.perl.org/group/perl.fwp/2006/07/msg3855.html>

Именование оператора детксая коляска(baby cart).

=item *

L<http://www.nntp.perl.org/group/perl.fwp/2006/07/msg3891.html>

Аристотель Пэгэлцис объясняет, как детская коляска может использоваться, чтобы сломать совмещение имен(break aliasing).

=item *

L<http://www.perlmonks.com/?node_id=564792>

I<Секретные Операторы Perl: логический оператор список сквош, x!!>,
Аристотель Пэгэлцис, описывает оператор предприятия(энтерпрайз).

=item *

L<http://www.nntp.perl.org/group/perl.fwp/2007/11/msg4006.html>

Описание тайного оператора пылающий X-Wing.

=item *

L<http://www.nntp.perl.org/group/perl.fwp/2007/11/msg4028.html>

Описание операторов отвертки и других, основанных на символе C<!>.

=item *

L<http://www.nntp.perl.org/group/perl.golf/2009/06/msg2524.html>

Описание четвертого оператора отвертки (позидрайв - крестовой).

=item *

L<http://www.nntp.perl.org/group/perl.fwp/2012/03/msg4169.html>

Описание оператора спермы/кайт.

=item *

L<http://www.nntp.perl.org/group/perl.fwp/2012/04/msg4192.html>

Предложение по дополнительному, благоприятному для семьи, нику для оператора гоатсе
, со вторым набором шуток внутри.

=item *

Эбботт и Костелло оператор был впервые представлен мне 2013-09-25
Ивом Ортоном в личных сообщениях.

Я пытался предложить «Лорел и Харди» как более международную и понятную
альтернативу, но оказывается Харди I<оба> жирные и
высокие в одном лице.

=item *

Ключ к оператору правды был описан мне 2013-09-28
Тоби Инкстером на  C<#moose> IRC канале и в личных сообщениях.

=item *

2014-02-18, на C<#perlfr> IRC канале, Дамиан Кроткин отмечает, что
он использует C<//()> чаще, чем C<||()>, на который отвечает Филипп Брюа
немедленно с именем "Наклоняющийся Аббат и Костелло", отмечая это
Аббат - высокий.

=back

Более тайные операторы не попали в этот список, потому что у них
пока нет имени.

=over 4

=item *

L<http://www.nntp.perl.org/group/perl.fwp/2007/11/msg4028.html>

Пересылка сообщения, которое представляет отверточные операторы, также представляет
несколько больше операторов, основанных на  C<!>.

=back

=head1 АВТОРСКОЕ ПРАВО

Copyright 2010-2014 Philippe Брюа (книга).

=head1 ЛИЦЕНЗИЯ

Эта документация предоставляется бесплатно; вы можете распространять её и/или изменить её
на тех же условиях как и сам Perl.

=head1 ПЕРЕВОДЧИКИ
 
=over
 
=item * Николай Мишин C<< <mishin@cpan.org> >>
 
=back
